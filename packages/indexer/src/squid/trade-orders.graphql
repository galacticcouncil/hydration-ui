fragment SwapDcaSchedule on DcaSchedule {
  id
  status
  assetInId
  budgetAmountIn: totalAmount
  totalExecutedAmountIn
}

fragment Swap on Swap {
  paraTimestamp
  operationType
  swapperId
  event {
    paraBlockHeight
    indexInBlock
  }
  swapInputs {
    nodes {
      asset {
        assetRegistryId
      }
      amount
    }
  }
  swapOutputs {
    nodes {
      asset {
        assetRegistryId
      }
      amount
    }
  }
  dcaScheduleExecutionEvent {
    scheduleExecution {
      schedule {
        ...SwapDcaSchedule
      }
      status
    }
  }
}

# TODO allow liquidity add/remove swaps when we know how to handle them
query UserSwaps(
  $swapperIdFilter: StringFilter
  $orFilter: [SwapFilter!]
  $offset: Int!
  $pageSize: Int!
) {
  swaps(
    filter: {
      swapperId: $swapperIdFilter
      operationType: { in: ["ExactIn", "ExactOut"] }
      or: $orFilter
    }
    offset: $offset
    first: $pageSize
    orderBy: ID_DESC
  ) {
    totalCount
    nodes {
      ...Swap
    }
  }
}

query UserOrders(
  $address: String!
  $assetInId: StringFilter
  $assetOutId: StringFilter
  $offset: Int!
  $pageSize: Int!
  $status: [String!]!
) {
  dcaSchedules(
    condition: { ownerId: $address }
    filter: {
      status: { in: $status }
      assetInId: $assetInId
      assetOutId: $assetOutId
    }
    offset: $offset
    first: $pageSize
    orderBy: PARA_BLOCK_HEIGHT_DESC
  ) {
    totalCount
    nodes {
      id
      status
      orderType
      assetIn {
        assetRegistryId
      }
      totalExecutedAmountIn
      budgetAmountIn: totalAmount
      singleTradeSize: amountIn
      assetOut {
        assetRegistryId
      }
      totalExecutedAmountOut
      period
    }
  }
}

query UserOpenOrdersCount($address: String!, $assetFilter: DcaScheduleFilter) {
  dcaSchedules(
    condition: { status: "Created", ownerId: $address }
    filter: $assetFilter
  ) {
    totalCount
  }
}

query DcaScheduleExecutions($scheduleId: String!) {
  dcaSchedule(id: $scheduleId) {
    assetIn {
      assetRegistryId
    }
    assetOut {
      assetRegistryId
    }
    dcaScheduleExecutionsByScheduleId(
      filter: { status: { in: ["Executed", "Failed"] } }
      orderBy: ID_DESC
    ) {
      nodes {
        id
        status
        amountIn
        amountOut
        dcaScheduleExecutionEventsByScheduleExecutionId(
          first: 1
          filter: { eventName: { in: ["Executed", "Failed"] } }
          orderBy: PARA_BLOCK_HEIGHT_ASC
        ) {
          nodes {
            event {
              paraBlockHeight
              indexInBlock
              block {
                timestamp
              }
            }
            errorState
          }
        }
      }
    }
  }
}

fragment RoutedTradeSwap on Swap {
  dcaScheduleExecutionEvent {
    scheduleExecution {
      schedule {
        ...SwapDcaSchedule
      }
    }
  }
}

query RoutedTrades(
  $address: String!
  $inputAssetRegistryIds: StringListFilter
  $outputAssetRegistryIds: StringListFilter
  $offset: Int!
  $pageSize: Int!
) {
  routedTrades(
    filter: {
      participantSwappers: { contains: [$address] }
      inputAssetRegistryIds: $inputAssetRegistryIds
      outputAssetRegistryIds: $outputAssetRegistryIds
    }
    offset: $offset
    first: $pageSize
    orderBy: PARA_BLOCK_HEIGHT_DESC
  ) {
    totalCount
    nodes {
      block {
        timestamp
      }
      routeTradeInputs {
        nodes {
          asset {
            assetRegistryId
          }
          amount
        }
      }
      routeTradeOutputs {
        nodes {
          asset {
            assetRegistryId
          }
          amount
        }
      }
      swaps(first: 1) {
        nodes {
          ...RoutedTradeSwap
        }
      }
    }
  }
}
